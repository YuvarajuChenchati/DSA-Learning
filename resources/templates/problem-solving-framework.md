# Problem-Solving Framework üß©

> **Systematic approach to solving algorithmic problems**

## üéØ Overview

This framework provides a structured approach to solving algorithmic problems, ensuring you can tackle any problem systematically and efficiently.

## üîç Step 1: Problem Analysis

### 1.1 Read and Understand
- [ ] **Read the problem**: Read the problem statement carefully
- [ ] **Identify key information**: Extract important details
- [ ] **Understand constraints**: Note input size limits and constraints
- [ ] **Identify input/output**: Understand expected input and output format
- [ ] **Look for examples**: Study provided examples

### 1.2 Ask Clarifying Questions
- [ ] **Input format**: What is the input format?
- [ ] **Output format**: What is the expected output format?
- [ ] **Edge cases**: What are the edge cases?
- [ ] **Constraints**: What are the time and space constraints?
- [ ] **Assumptions**: What assumptions can I make?

### 1.3 Identify the Problem Type
- [ ] **Data structure**: Array, string, tree, graph, etc.
- [ ] **Algorithm type**: Sorting, searching, dynamic programming, etc.
- [ ] **Pattern**: Two pointers, sliding window, fast/slow pointers, etc.
- [ ] **Complexity**: What complexity is expected?
- [ ] **Optimization**: Is optimization needed?

## üß† Step 2: Solution Design

### 2.1 Brute Force Approach
- [ ] **Start simple**: Begin with the simplest solution
- [ ] **Think step by step**: Break down the problem
- [ ] **Consider all cases**: Handle all possible cases
- [ ] **Estimate complexity**: Analyze time and space complexity
- [ ] **Identify bottlenecks**: Find areas for improvement

### 2.2 Optimize the Solution
- [ ] **Identify patterns**: Look for common algorithmic patterns
- [ ] **Choose data structures**: Select appropriate data structures
- [ ] **Optimize algorithms**: Improve algorithm efficiency
- [ ] **Reduce complexity**: Lower time or space complexity
- [ ] **Handle edge cases**: Consider boundary conditions

### 2.3 Plan Implementation
- [ ] **Outline steps**: Plan the implementation steps
- [ ] **Choose data structures**: Select appropriate data structures
- [ ] **Plan algorithms**: Design the algorithm flow
- [ ] **Consider edge cases**: Plan for edge case handling
- [ ] **Estimate complexity**: Final complexity analysis

## üíª Step 3: Implementation

### 3.1 Start Coding
- [ ] **Begin implementation**: Start coding the solution
- [ ] **Use clear variable names**: Choose descriptive names
- [ ] **Add comments**: Comment complex logic
- [ ] **Test as you go**: Test with examples
- [ ] **Handle edge cases**: Implement edge case handling

### 3.2 Code Quality
- [ ] **Clean code**: Write readable, well-structured code
- [ ] **Proper indentation**: Use consistent indentation
- [ ] **Meaningful names**: Use descriptive variable and function names
- [ ] **Modular design**: Break code into logical functions
- [ ] **Error handling**: Consider error conditions

### 3.3 Testing and Debugging
- [ ] **Test with examples**: Test with provided examples
- [ ] **Test edge cases**: Test boundary conditions
- [ ] **Debug issues**: Fix any bugs found
- [ ] **Verify correctness**: Ensure solution is correct
- [ ] **Optimize if needed**: Make improvements if time allows

## üîç Step 4: Verification

### 4.1 Test the Solution
- [ ] **Run examples**: Test with provided examples
- [ ] **Test edge cases**: Verify edge case handling
- [ ] **Check correctness**: Ensure solution is correct
- [ ] **Verify complexity**: Confirm complexity analysis
- [ ] **Test performance**: Check if solution meets requirements

### 4.2 Analyze Complexity
- [ ] **Time complexity**: Analyze time complexity
- [ ] **Space complexity**: Analyze space complexity
- [ ] **Compare with requirements**: Check if complexity meets requirements
- [ ] **Consider optimizations**: Think about further optimizations
- [ ] **Document complexity**: Document the complexity analysis

### 4.3 Review and Improve
- [ ] **Code review**: Review the code for improvements
- [ ] **Optimize if possible**: Make optimizations if time allows
- [ ] **Consider alternatives**: Think about alternative approaches
- [ ] **Document approach**: Document the solution approach
- [ ] **Prepare explanation**: Prepare to explain the solution

## üéØ Step 5: Communication

### 5.1 Explain the Solution
- [ ] **Walk through approach**: Explain your thought process
- [ ] **Describe algorithm**: Explain the algorithm used
- [ ] **Discuss complexity**: Explain time and space complexity
- [ ] **Handle questions**: Answer any questions about the solution
- [ ] **Discuss alternatives**: Mention alternative approaches

### 5.2 Handle Feedback
- [ ] **Listen actively**: Pay attention to feedback
- [ ] **Ask questions**: Ask for clarification if needed
- [ ] **Consider suggestions**: Consider suggested improvements
- [ ] **Implement changes**: Make changes if appropriate
- [ ] **Learn from feedback**: Use feedback to improve

## üìä Common Problem Patterns

### 1. Two Pointers
- **When to use**: Sorted arrays, palindromes, pairs
- **Time complexity**: O(n)
- **Space complexity**: O(1)
- **Examples**: Two sum, three sum, container with most water

### 2. Sliding Window
- **When to use**: Subarrays, substrings, fixed/variable window
- **Time complexity**: O(n)
- **Space complexity**: O(1) or O(k)
- **Examples**: Maximum sum subarray, longest substring

### 3. Fast and Slow Pointers
- **When to use**: Linked lists, cycle detection
- **Time complexity**: O(n)
- **Space complexity**: O(1)
- **Examples**: Cycle detection, middle of linked list

### 4. Merge Intervals
- **When to use**: Overlapping intervals, scheduling
- **Time complexity**: O(n log n)
- **Space complexity**: O(1)
- **Examples**: Meeting rooms, merge intervals

### 5. Cyclic Sort
- **When to use**: Numbers in range [1, n], missing/duplicate numbers
- **Time complexity**: O(n)
- **Space complexity**: O(1)
- **Examples**: Find missing number, find duplicates

## üß© Problem-Solving Strategies

### 1. Pattern Recognition
- [ ] **Identify patterns**: Look for common algorithmic patterns
- [ ] **Use templates**: Apply known pattern templates
- [ ] **Adapt patterns**: Modify patterns for specific problems
- [ ] **Practice patterns**: Practice with different pattern variations
- [ ] **Build intuition**: Develop pattern recognition skills

### 2. Divide and Conquer
- [ ] **Break down problem**: Divide problem into smaller parts
- [ ] **Solve subproblems**: Solve each subproblem
- [ ] **Combine solutions**: Combine subproblem solutions
- [ ] **Handle base cases**: Handle base cases properly
- [ ] **Optimize combination**: Optimize the combination step

### 3. Dynamic Programming
- [ ] **Identify subproblems**: Find overlapping subproblems
- [ ] **Define recurrence**: Define recurrence relation
- [ ] **Choose approach**: Select memoization or tabulation
- [ ] **Implement solution**: Implement the DP solution
- [ ] **Optimize space**: Optimize space complexity if possible

### 4. Greedy Approach
- [ ] **Identify greedy choice**: Find the greedy choice property
- [ ] **Prove optimality**: Prove the greedy choice is optimal
- [ ] **Implement solution**: Implement the greedy solution
- [ ] **Verify correctness**: Ensure solution is correct
- [ ] **Consider edge cases**: Handle edge cases properly

## üí° Tips for Success

### General Tips
- **Practice regularly**: Consistent practice is key
- **Start simple**: Begin with brute force, then optimize
- **Think out loud**: Explain your thought process
- **Test thoroughly**: Test with examples and edge cases
- **Learn from mistakes**: Analyze and learn from errors

### Technical Tips
- **Understand the problem**: Don't rush to code
- **Choose appropriate data structures**: Select the right tools
- **Consider complexity**: Always analyze time and space complexity
- **Handle edge cases**: Don't forget boundary conditions
- **Optimize when possible**: Look for improvements

### Communication Tips
- **Explain your approach**: Walk through your thought process
- **Ask questions**: Don't hesitate to ask for clarification
- **Listen to feedback**: Pay attention to suggestions
- **Stay calm**: Maintain composure under pressure
- **Be confident**: Trust in your abilities

## üìö Additional Resources

- [Problem Solving](https://www.geeksforgeeks.org/problem-solving/)
- [Algorithm Design](https://www.geeksforgeeks.org/algorithm-design/)
- [Coding Interview Tips](https://www.geeksforgeeks.org/coding-interview-tips/)
- [Pattern Recognition](https://www.geeksforgeeks.org/pattern-recognition/)

---

**Remember**: Problem-solving is a skill that improves with practice. Use this framework consistently, and you'll become more efficient at solving algorithmic problems! üöÄ
